<!DOCTYPE html>
<html>
<head>
	<title>Flow and Error Control</title>

				 <!-- LINKS FOR USING BOOTSTRAP ONLINE START -->
			   <!-- <meta charset="utf-8">
			    <meta name="viewport" content="width=device-width, initial-scale=1">
			    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css">
			    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
			    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.0/umd/popper.min.js"></script>
			    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js"></script> -->
			    <!-- LINKS FOR USING BOOTSTRAP ONLINE END-->
			    <meta charset="utf-8">
			  <meta name="viewport" content="width=device-width, initial-scale=1">
			  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
			  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
			  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>



			  <style type="text/css">
			     #myBtn {
			              display: none;
			              position: fixed;
			              bottom: 20px;
			              right: 30px;
			              z-index: 99;
			              font-size: 18px;
			              border: none;
			              outline: none;
			              background-color: red;
			              color: white;
			              cursor: pointer;
			              padding: 15px;
			              border-radius: 4px;
			            }

			            #myBtn:hover {
			              background-color: #555;
			            }
			   </style>
</head>
<body style="font-family: 'Open Sans', sans-serif;">

	<div class="container">
		<div class="jumbotron">
			<nav class="navbar navbar-inverse navbar-fixed-top">
					  
					    <div class="navbar-header">
					      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
					        <span class="icon-bar"></span>
					        <span class="icon-bar"></span>
					        <span class="icon-bar"></span>                        
					      </button>
					      <a class="navbar-brand" href="#">GATE | Computer Networks</a>
					    </div>
					    

					    <div class="collapse navbar-collapse" id="myNavbar">

							      <ul class="nav navbar-nav ">
							        <li><a href="cn.html">Syllabus</a></li>
							        <li class="dropdown">
							          <a class="dropdown-toggle" data-toggle="dropdown" href="#">Topics <span class="caret"></span></a>
							          <ul class="dropdown-menu">
							            <li><a href="introcn.html">Introduction</a></li>
							            <li><a href="topo.html">Topologies</a></li>
							            <li ><a href="concept.html">Concept of layers</a></li>
							            <li ><a href="lan.html">LAN Technologies</a></li>
							            <li class="active"><a href="flow.html">Flow and Error Control</a></li>
							            <li ><a href="ip.html">Internet Protocol(IPv4)</a></li>
							            <li ><a href="fragment.html">Concept Of Fragmentation</a></li>
							          </ul>
							        </li>
							        <li class="dropdown">
                                     		<a class="dropdown-toggle" data-toggle="dropdown" href="#">Quizzes<span class="caret"></span></a>
									          <ul class="dropdown-menu">
											            <li class="active"><a href="quiz.html">Quiz 1</a></li>
											            <li><a href="quiz1.html">Quiz 2</a></li>
											            <li><a href="quiz.html">Quiz 3</a></li>
											            <li><a href="quiz.html">Quiz 4</a></li>
									          </ul>
							        	</li>
							        <li><a href="Feedback.html">Feedback</a></li>
							      </ul>
						      
					    </div>
					  
					</nav>
					<p><b><u>FLOW AND ERROR CONTROL TECHNIQUES</u></b></p>
					<p>Now that we’re done with the introduction part of computer networks and how things generally work, we will try to examine the salient details of working of different layers in a computer network. As discussed earlier, physical layer will be excluded from the course content. Other layers will be discussed in almost complete detail, and questions from these layers are very frequent in competitive exams.</p>
					<p>So, let’s get started!</p>

					<p><b><u>Data Link Layer </u></b></p>
					<p>Data link layer is the second layer out of the 7 layered OSI model. It is responsible for node to node (hop to hop) delivery. Data link layer hides the details of the underlying hardware and presents itself to upper layers as a medium to communicate.  </p>

					<p>Data link layer has two sub-layers:</p>
					<p>
						<b>•	Logical Link Control:</b> It deals with protocols, flow-control, and error control<br/>
<b>•	Media Access Control:</b> It deals with actual control of media.
</p>

<p><b><u>The functionalities of Data Link Layer are:</u></b></p>
<p><b>•	Framing</b><br/>
Data-link layer takes packets from Network Layer and encapsulates them into frames. Then, it sends each frame bit-by-bit on the hardware. At receiver’ end, data link layer picks up signals from hardware and assembles them into frames.
</p>

<p><b>•	Addressing</b><br/>
Data-link layer provides layer-2 hardware addressing mechanism. Hardware address is assumed to be unique on the link. It is encoded into hardware at the time of manufacturing.
</p>

<p><b>•	Error Control</b><br/>
Sometimes signals may have encountered problem in transition and the bits are flipped. These errors are detected and attempted to recover actual data bits. It also provides error reporting mechanism to the sender.
</p>

<p><b>•	Flow Control</b><br/>
Stations on same link may have different speed or capacity. Data-link layer ensures flow control that enables both machines to exchange data on same speed.
</p>

<p><b>•	Multi-Access</b><br/>
When host on the shared link tries to transfer the data, it has a high probability of collision. Data-link layer provides mechanism such as CSMA/CD to equip capability of accessing a shared media among multiple Systems.
</p>

<p><b><u>FRAMING: </u></b></p>
<P>The data link layer needs to pack bits into frames, so that each frame is distinguishable from another. Framing in data link layer separates a message from one source to a destination by adding a sender’s and receiver’s address. Broadly speaking, there are two kinds of framing:</P>

<p><b><u>•	Fixed size framing:</u> </b>In this type of framing, there is no need to define any boundaries for the frames. The size itself acts as a delimiter. <br/>
<b><u>•	Variable size framing:</u></b> In variable size framing, we need to find a way to define the end of the frame and the beginning of the next. This has been usually done using two approaches: <br/>
a) Character Oriented protocols<br/>
In character oriented protocols, data to be carried are 8 bit characters from encoding systems like ASCII. This was popular technique when the only form of data exchanged was text. The header which carried the source and destination addresses along with other control information was also in multiples of 8 bits. To separate one frame from next, an 8-bit (1 byte) flag is added at the beginning and end of a frame. The flag could be any character which was not used for text communication. Figure below shows a frame in the character oriented protocol. 
</p>
<center><img src="pic/flow1.jpg" class="img-thumbnail"/></center>
<p>Now however with various kinds of data being sent any pattern used for the flag could also be a part of the information. If this happens, the receiver, when it encounters the flag pattern in the middle of data might think that it is the end of the frame. To solve this problem, byte stuffing strategy was used. In this, a special byte is added to the data section of the frame whenever there is a character with the same pattern as the flag. This byte is usually called the escape character (ESC) which has a predefined pattern. </p>
<center><img src="pic/flow2.jpg" class="img-thumbnail"/></center>
<p><b><u>b) Bit oriented protocols</u></b><br/>
In bit oriented protocols, the data section is a sequence of bits to be interpreted by the upper layers as the text, graphic, audio, video and so on. Most protocols use a special 8 bit pattern flag 01111110 as delimiter to define the beginning and the end of the frame. 
</p>
<center><img src="pic/flow3.jpg" class="img-thumbnail"/></center>
<p>To overcome the problem of having the flag in the middle as data being wrongly interpreted as the end of the frame, bit stuffing is used. Bit stuffing is the process of adding one extra 0 whenever five consecutive 1s follow a 0 in the data, so that the receiver does not mistakethe pattern 0111110 for a flag.</p>
<center><img src="pic/flow4.jpg" class="img-thumbnail"/></center>
<p><b><u>FLOW CONTROL </u></b><br/>

The most important responsibility of the data link layer is flow control. Flow control coordinates the amount of data that can be sent before receiving an acknowledgement. It is basically a set of procedures that tells the sender how much data it can transmit before it must wait for acknowledgement from the receiver. The flow of data must not be allowed to overwhelm the receiver. The receiving device must be able to inform the sending device before its limits are reached and request for sending fewer frames or stop temporarily. Incoming data must be checked and processed before they can be used. For this reason, each receiving device has a block of memory called buffer, reserved for storing incoming frames until they are processed. <br/>

Before we can move on to protocols used for flow control, we need to know various time delays that occur in network.<br/>

Various time delays involved in transmission of data are:<br/>

<b><u>1. Transmission time: </b></u>It is the amount of time from the beginning to the end of message transmission. It is the time from the first bit until the last bit of the message has left the transmitting node and been put on the channel. It depends on the size of the message that has to be sent. This time is actually the useful time in data transmission.<br/>
For calculation of transmission time, we consider the following:<br/>
Bandwidth of the channel which determines the number of bits per second we can transmit and the length of the message to be transmitted. <br/>
</p>
<center><img src="pic/flow5.jpg" class="img-thumbnail"/></center>

<p><b><u>2. Propagation delay:</u></b>It measures the time taken for a bit of data to travel from the source to the destination. It is independent of the length of the message but depends on the distance between the source and destination as well as the speed of propagation provided by the medium. This time is not useful but still cannot be neglected.</p>

<center><img src="pic/flow6.jpg" class="img-thumbnail"/></center>

<p><b><u>3. Processing and queue delays:</u></b> It is the time taken by each device that receives the message to process and forward or store the contents of the message depending upon whether it is the intended receiver of the message. Such delays are heavily dependent on the device and underlying channel and therefore cannot be fixed. Therefore, in most of the cases these delays are neglected</p>

<center><img src="pic/flow7.jpg" class="img-thumbnail"/></center>
<p>Therefore the total time (also called latency or delay) required for the message to be completely transmitted from the source to destination is: <br/>
Total Time = Transmission time (data) + Transmission time (acknowledgement) + Propagation delay (data) + Propagation delay (Acknowledgement) + Processing delay + Queue delay<br/>
Here since the acknowledgement is usually just 1 bit, the transmission time is negligible and the processing and queue delays are neglected since we don’t have a fixed method to calculate them. <br/>
Also, Propagation delay (data) = Propagation delay (acknowledgement) since the propagation delay is independent of length of message. Therefore, 
</p>
<center><img src="pic/flow8.jpg" class="img-thumbnail"/></center>
<p>FLOW CONTROL PROTOCOLS<br/>
The flow control protocols included in our syllabus are:<br/>
1. Stop-and-wait protocol<br/>
2. Go Back N protocol<br/>
3. Selective Repeat protocol
</p>
<center><img src="pic/flow9.jpg" class="img-thumbnail"/></center>
<p><b><u>Stop-AND-Wait Protocol</u></b>
In this protocol, the sender sends one frame at a time until it receives confirmation from receiver in the form of acknowledgement that it is okay to send the next frame. Both the sender and receiver have window size =1. 
</p>
<center><img src="pic/flow10.jpg" class="img-thumbnail"/></center>
<p>The efficiency of the stop-and-wait protocol</p>
<center><img src="pic/flow11.jpg" class="img-thumbnail"/></center>
<P>Here the useful time = TT   and Total time = TT + 2* PT<br/>
Therefore, <br/>
</P>
<center><img src="pic/flow12.jpg" class="img-thumbnail"/></center>
<p>Also taking a= PT/TT the above formula becomes:</p>
<center><img src="pic/flow13.jpg" class="img-thumbnail"/></center>
<p>Effective Bandwidth/Bandwidth utilization/Throughput determines how many bits you can actually transmit per unit time. </p>
<center><img src="pic/flow14.jpg" class="img-thumbnail"/></center>
<p>For instance, if the available bandwidth = 2 Mbps and efficiency of network = 50%<br/>
Then, the effective bandwidth (which the user will be able to use actually) is going to be just 1 Mbps (50/ 100 * 2). 
</p>
<p>Ques 1: Determine efficiency in the following cases:<br/>
a) Transmission time = 1ms, Propagation time = 1ms<br/>
b) Transmission time is double the propagation time<br/>
</p>
<button type="button" class="btn btn-info" data-toggle="collapse" data-target="#demo">See Solution</button><br/><br/>
										  <div id="demo" class="collapse">
                                            
                                            <p>Solution: <br/>
												a) Efficiency = 1/ 1+2a <br/>
												a= PT/TT = 1ms/1ms = 1<br/>
												= 1/ 1+2 = 1/3 = 33.33% <br/>
												Therefore, Efficiency = 33.33% <br/>
												b) Let PT be the propagation time<br/>
												TT = 2*PT<br/>
												a= PT/TT = PT/2PT = ½<br/>
												Efficiency = 1/1+2a<br/>
												= 1/1+ 2(1/2) = 1/1+1 = ½ = 50%<br/>
												Therefore, Efficiency = 50%<br/>
												</p>
										  </div>


										  <P>In simple stop-and-wait there are certain problems which one can face while transmission of data: <br/>
												<u>1. Packet Loss / Acknowledgment Lost </u><br/>
												The data packet being sent may get lost and not reach the receiver. Also, if the data has reached the receiver the acknowledgement from the receiver may get lost. In both the cases there is a deadlock, and both the sender and receiver will be idle. 
												</P>

										<center><img src="pic/flow15.jpg" class="img-thumbnail"/></center>
										<p>To overcome this situation, there is a time out timer that is set at both sender and receiver’s end. If this time out expires, the data/ acknowledgement are resent.</p>
										<center><img src="pic/flow16.jpg" class="img-thumbnail"/></center>
										<p><u>2. Duplicate Data acceptance</u>
											Considering the lost acknowledgement problem discussed above, when the data is sent again it is actually a duplicate packet which the receiver should identify and discard and simply resend the acknowledgement. But the receiver being unable to identify that it is the same packet accepts the duplicate packet.
											</p>
										<center><img src="pic/flow17.jpg" class="img-thumbnail"/></center>
										<p>To solve this problem, the data packets send by the source are numbered with sequence numbers. Each packet has a sequence number and same packet if sent again will have the same sequence number which will help the receiver in identifying duplicate packets and discard such packets. <br/>
On the same lines, the acknowledgement sent by the receiver is also numbered so that the sender can understand which packet is being acknowledged and which packet is being expected by the receiver. <br/>
This stop and wait protocol along with time out timer and sequence numbers is called as the Stop-&-Wait ARQ (Automatic Repeat request).
</p>

<p>

	<b>Important Points:</b><br/> 
a) In Stop-&-Wait ARQ, we use sequence numbers to number the frames. The sequence numbers are based on modulo-2 arithmetic.<br/>
b) In Stop-&-Wait ARQ, the acknowledgment number is always the sequence number of the next expected bit/packet.<br/>
c) Any data packet lost or corrupted is retransmitted by the sender. For this purpose, the sender keeps a copy of the packet being sent.<br/>
d) The timeout timer in Stop-&-Wait ARQ protocol is generally twice the round trip time. Round trip time here refers to the time taken by a bit to reach from sender to receiver and back to the sender. 

</p>
<p>
	Ques: If we need to send 10 packets using stop & wait and every 4th packet is lost then how many total packets the sender needs to send?</p>
	<button type="button" class="btn btn-info" data-toggle="collapse" data-target="#demo1">See Solution</button><br/><br/>
										  <div id="demo1" class="collapse">
										  	<img src="pic/flow18.jpg" class="img-thumbnail"/>
										  </div>


<p><b><u>Go Back-N Automatic Repeat Request</u></b><br/> 
To improve the efficiency of transmission, multiple frames must be in transit while waiting for acknowledgement. The first protocol which implements this is called Go-Back-N ARQ. In this protocol we send several frames before receiving acknowledgements; we keep a copy of these frames until the acknowledgement arrives. <br/> 
Sequence numbers are used to number the frames sequentially. Usually a set of bits in the header of each frame are set aside for sequence number therefore a range of numbers can be used as sequence numbers and then they are repeated. For instance, <br/> 
<b>If there are ‘m’ bits available for sequence numbers then the range of sequence numbers will be 0- 2^m – 1. The sequence numbers are modulo 2^m. </b><br/> 
<b><u>Sliding Window</u></b><br/> 
The sliding window is an abstract concept that defines the range of sequence numbers that is the concern of the sender and receiver. The sender and receiver need to deal with only a part of the possible sequence numbers. The range that concerns the sender is the send sliding window, while, the range that concerns the receiver is receive sliding window. <br/> 
The send window is an imaginary box covering the sequence numbers of the data frames which are in transit. In each window position, some of these sequence numbers define the frames that have been sent; others define those that can be sent. The maximum window size at any time can be 2^m-1.
</p>
<center><img src="pic/flow19.jpg" class="img-thumbnail"/></center>
<p>The window at any time divides the possible sequence number into four regions. The first region, from the far left to the left wall of the window, defines the sequence numbers of the frames that have already been acknowledged. The second region, defines the range of sequence numbers belonging to the frames that are sent but not acknowledged. This is the set of outstanding frames. The third range, defines the set of sequence numbers that can be sent but the corresponding data has not yet been received from the network. Finally, the fourth range defines the sequence numbers which cannot be used until the window slides. The send window slides one or more slots when an acknowledgement arrives. </p>
<p>Features of Go-Back-N<br/>
1. In the Go-back-N protocol, N stands for the window size of the sender (number of frames the sender can send at one time).<br/>
2. The window size of the receiver however is 1. This means while the sender sends N packets at a time the receiver will receive only 1 packet at a time.<br/>
3. Out of order packets are not accepted. <br/>
4. The send window size must be less than 2^m where m is the number of bits representing the sequence number. The range for sequence numbers possible is from 0 to 2^m-1. If the send window size equals 2^m, then duplicate frames can get accepted. <br/>
For instance, <br/>
Consider m=2, this means the size of the window should be less than 4<br/>
</p>
<center><img src="pic/flow20.jpg" class="img-thumbnail"/></center>
<p>Efficiency in case of Go Back N:<br/> 
Since, N packets are being sent at a given time the useful time (time during which data is being transmitted) increases. As a result, efficiency increases. <br/> 
The efficiency for Go back N protocol is <br/> 
</p>
<center><img src="pic/flow21.jpg" class="img-thumbnail"/></center>
<p>Here N is the window size of the sender (Number of packets that can be sent at a given time without waiting for acknowledgement) and ‘a’ represents the ratio of propagation time to transmission time, i.e., a = PT/TT  <br/>
But even though the efficiency increases many folds, there is a huge disadvantage in this protocol. The numbers of retransmissions involved in this case are huge. Even if one packet gets lost, the entire window needs to be resend again because the receiver will discard the packets received afterwards because until it receives the frame it has been waiting for. This leads to wastage of the bandwidth. <br/>
Ques: Calculate the window size when Go back N protocol is being used given the packet size = 50 bytes, propagation delay = 40ms and bandwidth = 150 mbps.
Solution: Window size refers to the number of frames that can be transmitted commutatively. <br/>
Efficiency = N/ 1+2a <br/>
a = TP/ TT <br/>
TP = 40 ms  <br/>
TT = L/BW = 50 * 8 / 150 * 106 <br/>
Efficiency = N / 1+ (2*40 * 10-3 *150* 106) /50*8 <br/>
= N/ 3000 <br/>
We will consider the maximum efficiency, i.e. 1 <br/>
1 = N/3000 <br/>
N = 3000 <br/>

<b><u>SELECTIVE REPEAT PROTOCOL</u></b> <br/>
This is one of the most intelligent protocols in flow control. This protocol uses two windows: a send window and a receive window. Here, the receive window is of the same size as the receive window.  As a result, this protocol accepts out of order packets as well. This gives it the advantage that if a frame is damaged or lost, then only the corrupted/lost frame needs to be resent not the entire window. The sender window size however is smaller as compared to Go Back N. <br/>
The send window is an abstract concept defining an imaginary box of size 2^m-1 with three variables: Sf, Sn, and Ssize. <br/>
</p>
<center><img src="pic/flow22.jpg" class="img-thumbnail"/></center>
<p><b>In Selective Repeat ARQ, the size of the sender and receiver windowmust be at most one-half of 2^m.</b></p>
<center><img src="pic/flow23.jpg" class="img-thumbnail"/></center>
<p>If there are m bits for the sequence number then max size of send window can be 2^m-1. </p>
<center><img src="pic/flow24.jpg" class="img-thumbnail"/></center>
<p>
	<b><u>Types Of Acknowledgements</u></b><br/>
There are two kinds of acknowledgements involved: <br/>
<b>1. Individual acknowledgement:</b> This involves sending acknowledgement for each individual frame separately. This kind of acknowledgement is used by Stop-and-wait because it only sends one frame at a time. Go back N and Selective Repeat protocols can also use this type of acknowledgment.<br/>
<b>Advantage:</b> More reliability <br/>
<b>Disadvantage:</b> Extra traffic over the network<br/>
<b>2. Cumulative acknowledgement:</b> This involves sending the acknowledgement for more than one frame at the same time. This is used by Go back N and Selective Repeat protocols but not by stop-and-wait protocol. For instance, if the sender has sent the frames 0,1,2,3 and all of the frames have been received and accepted by the receiver, the receiver can directly send acknowledgement number 4 instead of separately sending acknowledgements for 0,1 and 2. On receiving the acknowledgment, the sender will understand that all the previous frames have been received and accepted and the receiver is now expecting frame with sequence number 4. <br/>
<b>Advantage:</b> Less burden and traffic over the network<br/>
<b>Disadvantage:</b> Reliability is less as compared to individual acknowledgments<br/>
There is a special kind of acknowledgement in Selective Repeat protocol called the Negative acknowledgement. This signal is sent to reject a previously received message, or to indicate some kind of error in the frame received. 

</p>






										









			
		</div>
	</div>



<!-- RETURN TO TOP CODE RED SYMBOL -->
<button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>


<script>
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};

function scrollFunction() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
        document.getElementById("myBtn").style.display = "block";
    } else {
        document.getElementById("myBtn").style.display = "none";
    }
}

// When the user clicks on the button, scroll to the top of the document
function topFunction() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
}
</script>



</body>
</html>